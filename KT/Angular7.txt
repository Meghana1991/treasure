1) Angular has dependency with Node modules. For installing angular quickly we use angular-cli which is residing in node modules. Hence install angular-cli first

2) Angular needs multiple other node dependencies which are used for transpiling the angular code which is in transcript to javascript

3)If you want to use bootstrap in your application, then npm install bootstrap@3(version).To use this the angular should be aware of the bootstrap package which is added. Hence we need to mention it in configfiles angular.json in styles array. By default there is style.css which can be used to write css which applies for any module entire application. You can add bootstrap path to the angular.json config file

4)index.html file is the file served by the server.This would have some html tag <app-root> which is a selector for some component @Component({selector:'app-root'})
The app-root tag > app-root selector holding component gets loaded

5)The angular bootstrap - The angular code will actually be bundled up on 'ng serve" whenever any changes are done to the application and these bundles will be injected to the index.html in the script tags at the end by angular-cli.
You can cross check the bundles in view page source of index.html

The first code to get executed is the index.html which will have several script bundles in it which will trigger main.ts which will trigger AppModule
index.html > main.ts > AppModule's bootstrap array > AppComponent > then angular knows app-root resides here > <app-root> of index.html will be treated

6)The app.module.ts file is registration book. This is like you have to register each n everything you do in the app. Be it components, routes etc. Angular cannot keep looking every file you create but it can check this register book inorder to know which file to consider n which not. Registration is mandatory thing.

An NgModule is a class marked by the @NgModule decorator. @NgModule takes a metadata object that describes how to compile a component's template and how to create an injector at runtime. It identifies the module's own components, directives, and pipes, making some of them public, through the exports property, so that external components can use them. @NgModule can also add service providers to the application dependency injectors.

Modules are a great way to organize an application and extend it with capabilities from external libraries.

Angular libraries are NgModules, such as FormsModule, HttpClientModule, and RouterModule. Many third-party libraries are available as NgModules such as Material Design, Ionic, and AngularFire2.

NgModules consolidate components, directives, and pipes into cohesive blocks of functionality, each focused on a feature area, application business domain, workflow, or common collection of utilities.

Modules can also add services to the application. Such services might be internally developed, like something you'd develop yourself or come from outside sources, such as the Angular router and HTTP client.

Angular apps are built with on complex relationship of view classes (i.e. components, directives, and pipes) and data providers (i.e. services). In the early days of Angular2, NgModule did not exist and you had to declare every relationship in every component. It was maintenance nightmare.

7)Component's selectors can be written in different ways. 

@Component({
    selector : 'app-custom'
    selector : '[app-custom]'
    selector : '.app-custom'
})

and in html we should reference by -

<app-custom></app-custom>
<div app-custom></div>
<div class="app-custom"></div>

8)Data binding is communication between the HTML and TS file.

9) The binding can happen as 1 way or 2 way. 1 way can happen in 2 methods.
1 way types -
1)String interpolation - This is strictly for String only and not for number and it can also be a function that returns a string {{ someFromTs }} {{ 'directString' }} {{ someStringReturnFn() }}

but still if we give a number in {{}} it works because interpolation internally converts number to string. Ultimately you need to pass something which actually converts to string

2)Property binding - Usually the HTML code we write gets parsed and converted to DOM. But if we mention any attribute with [] then this would be considered for binding from Angular and HTML wont be considering it in initial time.

10) For Two-Way-Binding (covered in the next lecture) to work, you need to enable the ngModel  directive. This is done by adding the FormsModule  to the imports[]  array in the AppModule.

You then also need to add the import from @angular/forms  in the app.module.ts file:

import { FormsModule } from '@angular/forms'; 

Check app.component.ts for 1way and 2way binding
- In 1st input tag behaviour
- - Data is empty by default because it is not 2way binding
- - Enter any data and it updates the property and whereever we use the {{}} will be updated

- In 2nd input tag behaviour
- - Data is filled by default as it is 2way binding
- - Change the data in this, will change the {{}} but doesn't change the 1st input tag as it just one way.
- - We have removed the eventTriggered function as well as it is not required

1 way binding can do only 1 side binding, HTML - TS
2 way binding can do 2 side binding, HTML - TS and TS - HTML (TS-HTML can be seen in the initial value binding by 2nd input tag coming from ts)

11)Components vs Directives
- When we place Component's selector in HTML template, it means the template of component ie html should be placed there. Components are directives with template but Directives are the ones withou templates.

12)*ngIf if true, only then it will have the conditional element in DOM else it wont even have it in DOM

13)This ngMOdel will actually act like a keyup / keydown / input etc events because as soon as you keep entering every single key/alphabet the model gets updates on every keystok

14)Angular CLI - 
ng generate component component_name (or)
ng g c component_name

To prevent from creating spec files your can give - ng g c component_name --spec false

ng g c parentFolder/component_name --spec false

15)Model ie typescript model is something which defines how a object should look like and what all items it should have and also its like a blueprint.

A model is a simple class with properties and constructor which is called when we instantiate the class with object. Usually we import this model and instantiate it by new ModelObj(with par) which will call constructor

Here we are having a class below with properties defined and assigned to the class properties on instantiating class with new object.

export class Ingredients {
    public name: string;

    constructor(name) {
        this.name = name;
    }

}

(or)

/**
 * The above and below are same
 */
export class Ingredients {
    constructor(public name) { }
}

16)Generally the error message in the browser console will show the Component name and also the syntax and also the line number but the line number will be wrong because the file which it shows is the minified compiled form where line numer would obviously defined.

17)In Chrome developer tools > Source tab > you will see many bundles > one such is main.bundle.js

Also the webpack sub folders in the .ts file for debuggers and debugging

18)When parent to child component communication is happening then the recieving end should recieve the data from sender as @Input in the .ts and sender should send in [] in .html file.

When we are getting data INTO the component then INPUT
When we are passing data OUTSIDE the component  then OUTPUT
Think being in component shoes.

In case of child to parent communication -
The child component exposes an EventEmitter property with which it emits events when something happens. The parent binds to that event property and reacts to those events.
Create a plain event with EventEmitter and then use that event where you want to send some information to parent el
Then Output that event in .ts with @Output and also (eventname) = "reactTothisInParent($event)"
The reactTothisInParent($event) is actually a function in parent comp which gets called once the child event is triggered.

19)AThe applied to any component css, will apply only to them and not other components even if it is parent child . Even though it is expected behaviour of CSS to pick in 1 file and apply everywhere , still the angular actually stops it from doing it. Check the DOM for any element, it will have something like ng-content-ugo-1 something which makes it unique. So angular stops css to have global behaviour

20)If we want the angular to stop the encapsulation by _ngcontent-c0 etc then we need to mention it in the @Component decorator with encapsulation: Viewencapsulation.None which will make that respective component css behave like default by considering CSS global level and to not encapsulate with _ngcontent-c0. Any CSS written in this component will apply globally unless the files have their local CSS which has more priority than global.

21)Local references in template are one way where you can use for accessing the html element itself in to the ts file and also can be used for one way binding from html to ts only one side

This is good but we can have the access for the element only after some events like click etc but what if we want access before click or any function call? Then in that case -

22)View Child - This gives element reference of the element.
The main difference between the local reference and the viewchild is that, the local reference will be triggered on some event but the Viewchild can be even got with ngoninit as well withot any clicks or events.

These local ref and viewchild can be placed for any tags not just input. It can be for any div or anything

23)Viewchild has one more beauty. It can actually even work for the components as a whole. You can take any component and reference it and use its functions.

Viewchild in detail -
1) I am in main component, on some event in main component i want to show some data which is default hidden in the child component. This case i will use Viewchild.

I will take reference of the child component and then on parents component trigger i will call the child component's function which will show the data.

Also incase if parent and child both have same variable name and viewchild variablechange of child will not affect parent variable and it remains same as in parent variable value only

Best example for viewchild is - Assume you have parents page and child page both having loading icons.Assume LHS as P and RHS as C(child). On initial load of page, the loading icons of both P and C runs. On finish getting response of Parents data, the loading should stop in both ideally. So once i get response from Parents page i will trigger stopLoadingIcon() in Child by Viewchild. On some action in parent i want to change something in child.

24)Something which is kept inside a component tags will not be present and is useless.   <app-child2>Hiiiiiii</app-child2>
here the Hiiiiiii will not be even considered.
But if i want my component to have some data inside beginning and ending tag then i can use ng-content.

I will mark or place ng-content tag in app-child2 component in some place where angular can actually put data inside this ngcontent the data between app-child2 tags.

25)Whenever a component is instantiated it goes through some phases
We have some chances to hook into these phases and execute any code if needed and
some of them are ngOnchanges ngOninit
<THE ORDER OF LIFECYCLE HOOKS ARE AS BELOW ORDERED>
1)The first phase is ngOnChanges - when new component is created and also wheneverour @Input properties change
2)The second is ngOnInit - when a component is initialised ie after the constructor when basic DOM is created
3)ngDoCheck - whenever change detection runs - whenever something changes in TEMPLATE either property value change or any change in render in the template. Example: when a button is clicked, a event is triggered, or on observable or timer etc are the cases where change detection runs and this ngDoCheck is triggered
4)ngAfterContentInit - Whenever the ng-content is changed.
5)ngAfterViewInit - Whenever the view of component has been finished initialising or rendered
6)ngAfterViewChecked - Whenever we are sure that all changes are displayed/rendered in the view or that the change detection are all done.
7)ngOnDestroy - whenever a component is about to be destroyed.

26)ngOnChanges -
* Triggered whenever there is change in the @Input which means
* @Input is coming as input to the child component from parent componen
* But ideally both of the child and parent variable which is communicated between them are pointing to same location in the memory
* Hence, any change in the parent variable will trigger child's ngOnChanges because the variable is sent to the child component

This arguement SimpleChanges will actually give us old value, current value which might be useful for us to perform any action if needed.

27)ngDoCheck calls on every change detection be it promises returing some result or be it any timer or click events. It is not good practise to actually write something in this hook due to performance issue.

28)Shadow DOM - is an internal DOM of your component that is defined by you (as a creator of the component) and hidden from an end-user. 
Light DOM - is a DOM that an end-user of your component supply into your component.
The difference between @ViewChildren and @ContentChildren is that @ViewChildren look for elements in Shadow DOM while @ContentChildren look for them in Light DOM.

29)Directives are used for DOM manipulation by either adding elements or removing or attaching events or etc, Also used for adding styles etc. Basically HTML modification will be handled by the directives.

Directives are of 2 types namely - Structural and Attribute Directives.
The Structural directives will modify the structure of the DOM by adding removing elements. Example: If *ngIf is not matching the condition then it removes that el from DOM. The Structural directives are appended with * in the beginning like *ngIf and *ngFor
The Attribute directives will modify that particular element alone by changing the properties of the element
We cannot have more than 1 Structural directive on same element like *ngFor *ngIf - Structural.
Examples for attribute are ngStyle ngClass

30) @Directive({ selector : '[attributeOfEl]' })
    @Directive({ selector : 'elementitself' })

31) ElementRef which is used in basic-highlighter directive actually modifies the DOM which is not good practise. 
Using ElementRef doesn't directly make your site less secure. The Angular team is just saying "Hey, you may use this,just be careful with it".If you are only using an ElementRef to get information, like in your example a certain width, there is no security risk involved at all. It's a different story when you use an ElementRef to modify the DOM. There, potential threats can arise. Such an example could be:
@ViewChild('myIdentifier')
myIdentifier: ElementRef

ngAfterViewInit() {
  this.myIdentifier.nativeElement.onclick = someFunctionDefinedBySomeUser;
}

The problem with this is that it gets inserted directly into the DOM, skipping the Angular sanitisation mechanisms. What are sanitisation mechanisms? Usually, if something in the DOM is changed via Angular, Angular makes sure it's nothing dangerous. However, when using ElementRef to insert something into the DOM, Angular can't guarantee this. So it becomes your responsibility that nothing bad enters the DOM when using ElementRef. An important keyword here is XSS (Cross-Site Scripting).

To summarise: If you poll the DOM for information, you are safe. If you modify the DOM using ElementRef, make sure the modifications don't possibly contain malicious code.

Hence use Renderer instead of ElementRef

32)To react to the EVENTS performed on the ELEMENT on which the directive resides we need to use something called Hostlistener

33)Hostlistener and HostBinding refers to HOST which means the element where we have attached the directive.
HostListener listens to event that HOST sends
HostBinding binds to attributes of the HOST

34)How the *ngIf is transformed to [ngIf] inside a ng-template behind the scenes here.

35)The *some in either custom or standard directive gets transformed to [some] in the ng-template tag. Check C:\mySpace\treasure\treasure\treasure\KT\ng-mean-todo-project\src\app\directives\structural.directive.ts