1) Angular has dependency with Node modules. For installing angular quickly we use angular-cli which is residing in node modules. Hence install angular-cli first

2) Angular needs multiple other node dependencies which are used for transpiling the angular code which is in transcript to javascript

3)If you want to use bootstrap in your application, then npm install bootstrap@3(version).To use this the angular should be aware of the bootstrap package which is added. Hence we need to mention it in configfiles angular.json in styles array. By default there is style.css which can be used to write css which applies for any module entire application. You can add bootstrap path to the angular.json config file

The old version of angular-cli is replaced with angular.json

All builds make use of bundling, and using the --prod flag in ng build --prod or ng serve --prod will also make use of uglifying and tree-shaking functionality.
The Angular CLI is a tool to initialize, develop, scaffold and maintain Angular applications
Bundling is a simple feature that makes it easier to combine multiple files into one

The Goal of Angular CLI
The Angular CLI creates, manages, builds and test your Angular projects. It's built on top of the Angular DevKit.

The Goal of DevKit
DevKit's goal is to provide a large set of libraries that can be used to manage, develop, deploy and analyze your code.

angular.json - CLI configuration defaults for all projects in the workspace, including configuration options for build, serve, and test tools that the CLI uses, such as TSLint, Karma, and Protractor. 

4)index.html file is the file served by the server.This would have some html tag <app-root> which is a selector for some component @Component({selector:'app-root'})
The app-root tag > app-root selector holding component gets loaded

5)The angular bootstrap - The angular code will actually be bundled up on 'ng serve" whenever any changes are done to the application and these bundles will be injected to the index.html in the script tags at the end by angular-cli.
You can cross check the bundles in view page source of index.html

The first code to get executed is the index.html which will have several script bundles in it which will trigger main.ts which will trigger AppModule
index.html > main.ts > AppModule's bootstrap array > AppComponent > then angular knows app-root resides here > <app-root> of index.html will be treated

6)The app.module.ts file is registration book. This is like you have to register each n everything you do in the app. Be it components, routes etc. Angular cannot keep looking every file you create but it can check this register book inorder to know which file to consider n which not. Registration is mandatory thing.

An NgModule is a class marked by the @NgModule decorator. @NgModule takes a metadata object that describes how to compile a component's template and how to create an injector at runtime. It identifies the module's own components, directives, and pipes, making some of them public, through the exports property, so that external components can use them. @NgModule can also add service providers to the application dependency injectors.

Modules are a great way to organize an application and extend it with capabilities from external libraries.

Angular libraries are NgModules, such as FormsModule, HttpClientModule, and RouterModule. Many third-party libraries are available as NgModules such as Material Design, Ionic, and AngularFire2.

NgModules consolidate components, directives, and pipes into cohesive blocks of functionality, each focused on a feature area, application business domain, workflow, or common collection of utilities.

Modules can also add services to the application. Such services might be internally developed, like something you'd develop yourself or come from outside sources, such as the Angular router and HTTP client.

Angular apps are built with on complex relationship of view classes (i.e. components, directives, and pipes) and data providers (i.e. services). In the early days of Angular2, NgModule did not exist and you had to declare every relationship in every component. It was maintenance nightmare.

7)Component's selectors can be written in different ways. 

@Component({
    selector : 'app-custom'
    selector : '[app-custom]'
    selector : '.app-custom'
})

and in html we should reference by -

<app-custom></app-custom>
<div app-custom></div>
<div class="app-custom"></div>

8)Data binding is communication between the HTML and TS file.

9) The binding can happen as 1 way or 2 way. 1 way can happen in 2 methods.
1 way types -
1)String interpolation - This is strictly for String only and not for number and it can also be a function that returns a string {{ someFromTs }} {{ 'directString' }} {{ someStringReturnFn() }}

but still if we give a number in {{}} it works because interpolation internally converts number to string. Ultimately you need to pass something which actually converts to string

2)Property binding - Usually the HTML code we write gets parsed and converted to DOM. But if we mention any attribute with [] then this would be considered for binding from Angular and HTML wont be considering it in initial time.

10) For Two-Way-Binding (covered in the next lecture) to work, you need to enable the ngModel  directive. This is done by adding the FormsModule  to the imports[]  array in the AppModule.

You then also need to add the import from @angular/forms  in the app.module.ts file:

import { FormsModule } from '@angular/forms'; 

Check app.component.ts for 1way and 2way binding
- In 1st input tag behaviour
- - Data is empty by default because it is not 2way binding
- - Enter any data and it updates the property and whereever we use the {{}} will be updated

- In 2nd input tag behaviour
- - Data is filled by default as it is 2way binding
- - Change the data in this, will change the {{}} but doesn't change the 1st input tag as it just one way.
- - We have removed the eventTriggered function as well as it is not required

1 way binding can do only 1 side binding, HTML - TS
2 way binding can do 2 side binding, HTML - TS and TS - HTML (TS-HTML can be seen in the initial value binding by 2nd input tag coming from ts)

11)Components vs Directives
- When we place Component's selector in HTML template, it means the template of component ie html should be placed there. Components are directives with template but Directives are the ones withou templates.

12)*ngIf if true, only then it will have the conditional element in DOM else it wont even have it in DOM

13)This ngMOdel will actually act like a keyup / keydown / input etc events because as soon as you keep entering every single key/alphabet the model gets updates on every keystok

14)Angular CLI - 
ng generate component component_name (or)
ng g c component_name

To prevent from creating spec files your can give - ng g c component_name --spec false

ng g c parentFolder/component_name --spec false

15)Model ie typescript model is something which defines how a object should look like and what all items it should have and also its like a blueprint.

A model is a simple class with properties and constructor which is called when we instantiate the class with object. Usually we import this model and instantiate it by new ModelObj(with par) which will call constructor

Here we are having a class below with properties defined and assigned to the class properties on instantiating class with new object.

export class Ingredients {
    public name: string;

    constructor(name) {
        this.name = name;
    }

}

(or)

/**
 * The above and below are same
 */
export class Ingredients {
    constructor(public name) { }
}

16)Generally the error message in the browser console will show the Component name and also the syntax and also the line number but the line number will be wrong because the file which it shows is the minified compiled form where line numer would obviously defined.

17)In Chrome developer tools > Source tab > you will see many bundles > one such is main.bundle.js

Also the webpack sub folders in the .ts file for debuggers and debugging

18)When parent to child component communication is happening then the recieving end should recieve the data from sender as @Input in the .ts and sender should send in [] in .html file.

When we are getting data INTO the component then INPUT
When we are passing data OUTSIDE the component  then OUTPUT
Think being in component shoes.

In case of child to parent communication -
The child component exposes an EventEmitter property with which it emits events when something happens. The parent binds to that event property and reacts to those events.
Create a plain event with EventEmitter and then use that event where you want to send some information to parent el
Then Output that event in .ts with @Output and also (eventname) = "reactTothisInParent($event)"
The reactTothisInParent($event) is actually a function in parent comp which gets called once the child event is triggered.

19)AThe applied to any component css, will apply only to them and not other components even if it is parent child . Even though it is expected behaviour of CSS to pick in 1 file and apply everywhere , still the angular actually stops it from doing it. Check the DOM for any element, it will have something like ng-content-ugo-1 something which makes it unique. So angular stops css to have global behaviour

20)If we want the angular to stop the encapsulation by _ngcontent-c0 etc then we need to mention it in the @Component decorator with encapsulation: Viewencapsulation.None which will make that respective component css behave like default by considering CSS global level and to not encapsulate with _ngcontent-c0. Any CSS written in this component will apply globally unless the files have their local CSS which has more priority than global.

21)Local references in template are one way where you can use for accessing the html element itself in to the ts file and also can be used for one way binding from html to ts only one side

This is good but we can have the access for the element only after some events like click etc but what if we want access before click or any function call? Then in that case -

22)View Child - This gives element reference of the element.
The main difference between the local reference and the viewchild is that, the local reference will be triggered on some event but the Viewchild can be even got with ngoninit as well withot any clicks or events.

These local ref and viewchild can be placed for any tags not just input. It can be for any div or anything

Viewchild is used for even directives.

23)Viewchild has one more beauty. It can actually even work for the components as a whole. You can take any component and reference it and use its functions.

Viewchild in detail -
1) I am in main component, on some event in main component i want to show some data which is default hidden in the child component. This case i will use Viewchild.

I will take reference of the child component and then on parents component trigger i will call the child component's function which will show the data.

Also incase if parent and child both have same variable name and viewchild variablechange of child will not affect parent variable and it remains same as in parent variable value only

Best example for viewchild is - Assume you have parents page and child page both having loading icons.Assume LHS as P and RHS as C(child). On initial load of page, the loading icons of both P and C runs. On finish getting response of Parents data, the loading should stop in both ideally. So once i get response from Parents page i will trigger stopLoadingIcon() in Child by Viewchild. On some action in parent i want to change something in child.

24)Something which is kept inside a component tags will not be present and is useless.   <app-child2>Hiiiiiii</app-child2>
here the Hiiiiiii will not be even considered.
But if i want my component to have some data inside beginning and ending tag then i can use ng-content.

I will mark or place ng-content tag in app-child2 component in some place where angular can actually put data inside this ngcontent the data between app-child2 tags.

25)Whenever a component is instantiated it goes through some phases
We have some chances to hook into these phases and execute any code if needed and
some of them are ngOnchanges ngOninit
<THE ORDER OF LIFECYCLE HOOKS ARE AS BELOW ORDERED>
1)The first phase is ngOnChanges - when new component is created and also wheneverour @Input properties change
2)The second is ngOnInit - when a component is initialised ie after the constructor when basic DOM is created
3)ngDoCheck - whenever change detection runs - whenever something changes in TEMPLATE either property value change or any change in render in the template. Example: when a button is clicked, a event is triggered, or on observable or timer etc are the cases where change detection runs and this ngDoCheck is triggered
4)ngAfterContentInit - Whenever the ng-content is changed.
5)ngAfterViewInit - Whenever the view of component has been finished initialising or rendered
6)ngAfterViewChecked - Whenever we are sure that all changes are displayed/rendered in the view or that the change detection are all done.
7)ngOnDestroy - whenever a component is about to be destroyed.

26)ngOnChanges -
* Triggered whenever there is change in the @Input which means
* @Input is coming as input to the child component from parent componen
* But ideally both of the child and parent variable which is communicated between them are pointing to same location in the memory
* Hence, any change in the parent variable will trigger child's ngOnChanges because the variable is sent to the child component

This arguement SimpleChanges will actually give us old value, current value which might be useful for us to perform any action if needed.

27)ngDoCheck calls on every change detection be it promises returing some result or be it any timer or click events. It is not good practise to actually write something in this hook due to performance issue.

28)Shadow DOM - is an internal DOM of your component that is defined by you (as a creator of the component) and hidden from an end-user. 
Light DOM - is a DOM that an end-user of your component supply into your component.
The difference between @ViewChildren and @ContentChildren is that @ViewChildren look for elements in Shadow DOM while @ContentChildren look for them in Light DOM.

29)Directives are used for DOM manipulation by either adding elements or removing or attaching events or etc, Also used for adding styles etc. Basically HTML modification will be handled by the directives.

Directives are of 2 types namely - Structural and Attribute Directives.
The Structural directives will modify the structure of the DOM by adding removing elements. Example: If *ngIf is not matching the condition then it removes that el from DOM. The Structural directives are appended with * in the beginning like *ngIf and *ngFor
The Attribute directives will modify that particular element alone by changing the properties of the element
We cannot have more than 1 Structural directive on same element like *ngFor *ngIf - Structural.
Examples for attribute are ngStyle ngClass

30) @Directive({ selector : '[attributeOfEl]' })
    @Directive({ selector : 'elementitself' })

31) ElementRef which is used in basic-highlighter directive actually modifies the DOM which is not good practise. 
Using ElementRef doesn't directly make your site less secure. The Angular team is just saying "Hey, you may use this,just be careful with it".If you are only using an ElementRef to get information, like in your example a certain width, there is no security risk involved at all. It's a different story when you use an ElementRef to modify the DOM. There, potential threats can arise. Such an example could be:
@ViewChild('myIdentifier')
myIdentifier: ElementRef

ngAfterViewInit() {
  this.myIdentifier.nativeElement.onclick = someFunctionDefinedBySomeUser;
}

The problem with this is that it gets inserted directly into the DOM, skipping the Angular sanitisation mechanisms. What are sanitisation mechanisms? Usually, if something in the DOM is changed via Angular, Angular makes sure it's nothing dangerous. However, when using ElementRef to insert something into the DOM, Angular can't guarantee this. So it becomes your responsibility that nothing bad enters the DOM when using ElementRef. An important keyword here is XSS (Cross-Site Scripting).

To summarise: If you poll the DOM for information, you are safe. If you modify the DOM using ElementRef, make sure the modifications don't possibly contain malicious code.

Hence use Renderer instead of ElementRef

If you want to observe the events happening in the element where directive is placed then use hostlistener

32)To react to the EVENTS performed on the ELEMENT on which the directive resides we need to use something called Hostlistener

33)Hostlistener and HostBinding refers to HOST which means the element where we have attached the directive.
HostListener listens to event that HOST sends
HostBinding binds to attributes of the HOST

Host Listener is the one which listens to its host's(El where directive is placed) events
Host Binding is the one which binds its host's(el where directive is placed) attributes
ElementRef can be used alternatively to get the access to element
Renderer can be used to changing the looks may be styles colors

34)How the *ngIf is transformed to [ngIf] inside a ng-template behind the scenes here.

35)The *some in either custom or standard directive gets transformed to [some] in the ng-template tag. Check C:\mySpace\treasure\treasure\treasure\KT\ng-mean-todo-project\src\app\directives\structural.directive.ts

36)Services - These are the ones who are like central repositary / business unit which will be used in many places

37)You can instantiate the service in in-appropriate manner by calling the new Object as in fetchData() of app.component.ts BUT angular doesnot encourage it

38)There is something called Injectable which tells that our component has dependencies with the service and we need to inject it. The dependency injection injects the instance of the class(service) to our component automatically.

39)We can inject the services inside providers array of component directly and also in app module (@NgModule). If in component level, then the service applies for that particular component and its children and its children and so on... but not for its parents.
If you inject in the providers array of @NgModule, then it is applied globally.

The problem is when we inject in the app component which is parents of all it will have a instance of the service. The child most might again declare again the providers service which will override the parent component instanc
This is called heirarchical instances. Check example of example1 and example-child

VERY importantly try to remove the providers array in example1 and example-child and declare it in the @NgModule and see if updation is happening as expected. It is happening as expected

40)I want to inject service inside a service. How?
@Injectable tells angular that something can be injected in this service. We write @Injectable in the service NOT if we want to inject it to component BUT if we want to inject some other service to that service.

41)If you are using Angular 6+ then you can use a new syntax for adding the services to providers[].
Instead of adding a service class to the providers[]  array in AppModule , you can set the following config in @Injectable() :

@Injectable({providedIn: 'root'})
export class MyService { ... }
This is exactly the same as:

export class MyService { ... }
and
import { MyService } from './path/to/my.service';
 
@NgModule({
    ...
    providers: [MyService]
})
export class AppModule { ... }

The "new syntax" does offer one advantage though: Services can be loaded lazily by Angular (behind the scenes) and redundant code can be removed automatically. This can lead to a better performance and loading speed - though this really only kicks in for bigger services and apps in general.

42) Shared services vs @Input @Output

It so happens that you can manage the @Input and @Output using services. You can emit and subscribe using services instead of @Input@Output. 

@Input API is used when you have parent-child-grandchild scenario. When you have routing and sibling components then the @Input API will not help you everywhere. You have to manage in parent and child, if you want two way communication. Later, over the time it becomes complex to manage.

When you have routing and parent-child-grandchild / sibling components, you can go with shared service. If variables are changing in service, you can update component using RXjs library. You have to manage everything in one place and subscribe to observable in component where you plan to use service.

So, I according to me shared service is a good solution with Rxjs library. You can make service singleton by injecting it into bootstrap function.

43) Spread syntax ...
var some = [1,2,3];
function someone(a,b,c){
    console.load(a,b,c) // 1 2 3
}

someone(...some)

------------------------------------------------------------------------------------------------------
var some = [1,2,3];
function someone(a,b,c,d){
    console.load(a,b,c,d) // 1 2 3 "phew"
}

someone(...some,"phew")

44)Routing - This needs to be configured in the app.module.ts

45) const routes: Routes = [ { path : 'users', component : '' } ]

Here the type Routes is important. It is a array of objects. path should not be given with /
In the imports of app.module.ts you need to add RouterModule.forRoot(routes)
Now we should tell angular where to display the component data on selecting routes. We should mark a place where we should load the data on routing using <router-outlet>

46) Generally we use href of <a> tag to do navigations. But what happens if you do it inside angular?Will it be SPA? NOOO. It still obviously reloads the page as we are not using any angular given utility. 

One should use routerLink inorder to make it SPA. Check C:\mySpace\treasure\treasure\treasure\KT\ng-mean-todo-project\src\app\routing-example\routing-example.component.html for details

47)The router.navigate is used to navigate to different routes in the ts file check example home.component.ts. 

To get the changes of the URL params(:id/:name in the app module ts file) we are using 
this.route.params.subscribe()

To get the changes of the queryParams
this.route.queryParams.subscribe()

To get the changes of the fragments
this.route.fragment.subscribe()

To get the data from the routes
this.route.data.subscribe()

48) For understanding in router.params and router.snapshot Check this C:\mySpace\treasure\treasure\treasure\KT\ng-mean-todo-project\src\app\routing-example\users\user\user.component.ts

49)The standard subscriptions would be destroyed on destroying the component by angular. However you can do it manually by ngOnDestroy() by unsubscribing it. Angular already does it for us but if we add own observables then we might have to clean it well. Custom subscriptions should be erased because the components would be created on route and destroyed on changing route and created again on route but the custom subscription would stay in the memory always

50)Check C:\mySpace\treasure\treasure\treasure\KT\ng-mean-todo-project\src\app\routing-example\servers\servers.component.html for understanding how we can write routing in HTML

51)Handling routing in HTML - servers.component.html
Handling routing in TS - home.component.ts

52)To convert the string to number, add a + in the front,

var some = "1"
console.log(+some) //1

53)Children routes can be added by adding children : [] to the route object.
Like how there is a single outlet for the entire app in the app.component.html, now for sub server or children of the server component should also be having a outlet considering the servers.html as the parent or root for the children. Hence we need to be adding a router-outlet for the children 

54){ path : 'not-found', component : PageNotFoundComponent},
  { path : '**', redirectTo : '/not-found'},
This ** is used for any junk routes. This ** basically means anything which is not defined in here
The angular parses the routes as it appears in the order. If you place the ** wild card in the beginning then it always goes to not-found. 

55)I have a scenario where i need to load the servers users or edit them only if user is logged in. I can do it by checking each component for user logged in or not but i cannot do it as it is cumbersome and lengthy method. We can make use of angular guards like canActivate

We can run some code at our defined time using guards.

Guards can be placed in the app.route.ts with canActivate with [guardnames] inside the route object. It eventually applies to all the children 

For example, The servers is the root path and has children as editServer updateServer routes below. On canActivate on the root server, it will eventually adds guard to the children

If you want only certain children or to ONLY children to have the guard then use canActivateChild. Check home.component.html for details

Guards can be created from cli as - ng g guard auth

C:\mySpace\treasure\treasure\treasure\KT\MEAN\nodejs\3_Super_Node_Apps\angular-authorisation-meanjs\ngApp\src\app\auth.guard.ts

56)If you want the user to prevent accidently navigating to back or navigating without clicking SAVE or UPDATE etc scenarios then use canDeActivate

57)interface is the one which makes a class to have the defined functions and properties upon importing or implementing it.

58)We can fetch static and dynamic data from the routes. For static data we need to configure the route path with data object. Check example : error-page.component.ts

Incase of dynamic data, we need to fetch data before the routing is done. Resolver is a guard which does something for us before the component is loaded or routing has occured. The canActivate will also do something before the component is loaded BUT this case is different where it fetches some data and not deciding like to show or not the compoentn like canActivate. Resolver will execute some code befoer the component is loaded

59)Generally what happens if you host your app in the server? localhost:4200/servers, this should ideally take you to the /servers route of angular like how it happens in the local but in the production, the /servers will be seen by the web server and it searches for /servers file and throws NOT FOUND. We should just serve the index.html to the webserver and let the angular handle the routing for us, to do this we need to enable useHash:true in forRoot()

We just have 1 file, index.html containing the angular app here. After making it as useHash:true then we get a #, so whatever comes after the # will not be considered by the webserver

60)  { path: '', redirectTo : '/recipes' , pathMatch: 'full'},
Every path would have prefix of ''(not empty) so we need to explicitly tell "full" otherwise it gets confused/

61) { path: ':id' , component: Somecomponent}
    { path: 'new' , component: Nomecomponent}
Here if the user hits /new it takes to Somecomponent because the order matters. Hence
 { path: 'new' , component: Nomecomponent}
 { path: ':id' , component: Somecomponent}

62)relativeTo inside the navigate method of route -  This is used when we are in the child route and want to pick the path from the parents route and then append it to where you want to navigate
this.router.navigate()

63)Promises and callbacks can be used to handle a request but somehow angular suggests to use observable from Rxjs. Just another approach

64)Rxjs version will be in package.json. The Rxjs-compat installation will unlock all the older version of the rxjs syntax but rxjs 6 onwards will no longer use older syntaxes. Still if you want to see then install Rxjs.compat

64)Observables C:\mySpace\treasure\treasure\treasure\KT\observables - 
There are Angular standard observables and we can create custom observables also
Standard includes the this.route.params.subscribe() which keeps giving us new data on any event instead of refreshing the page.

Any observable handles response and error and complete. We can catch it if needed

Observer - Observable is as good as Sender -  Reciever
this.router.params.subscribe() is observer and in our custom code we write code which should react to change in params which is observable

As in the homecomponent, i have a observer which keeps sending or observer.nexting the data, then if i switch the component to user1 or user2 leaing the homecomponent still the observable is listening without getting destroyed. In case of angular observers, the angular unsubscribes them for us but custom observable should be handled by us
If we dont handle the custom observable withou unsubscribing then it leads to memory leak.

https://rxjs-dev.firebaseapp.com/api

Subject of rxjs is also like observable but it is much more better than it and allows us to CONVINIENTLY push data/ emit data on our requirement in the code.
Subject is observer and observable both together.

Example :  In observer we use observer.next(somedata) and in recieving end we just do observable.subscribe().
But incase of the subject, it can do both being either observer or observable

65) Usually we compare the Subject to EventEmitter but it is always good to use Subject over EventEmitter.
It is very simple. Define a subject in the service. Use it in component-a to emit some value to some other component using .next. On other hand use componen-b to .subscribe() it for changes

66)There are some operators which will help us to transform the data into something else but still remain in observable world like .map

67).map - It takes the response object and modifies it as per our requirement and importantly it returns the modfied part as observable only like initial state to which we can subscribe and use it

68)to uninstall certain package - npm uninstall --save rxjs-compat

69)In case of rxjs > 6, imports would change, any operators usege like .map etc would go inside a pipe() which actually can take multiple operators

EventEmitter and Subject behaves almost same but Subject is better than that.
In EventEmitter we use .emit() but in subject we use .next()
The observable or subject can be unsubscribed and check if EventEmitter can be too?

70)Angular Forms -
Import FormsModule in the app.module.ts
Whichever whatever feilds you want to have control on or whatever fields you want to use in the javascript, only those you need to bind with name and ngModel properties. Angular converts the <form> into a javascript object. We can have access to that object by using a local reference to the form tag with ngForm. Example: C:\mySpace\treasure\treasure\treasure\KT\forms-td-start\forms-td-start\src\app\app.component.html

Approach 1 - Local Reference      

<form (ngSubmit)="onSubmit(f)" #f = "ngForm">
where the #f is the local reference method of sending data

Approach 2 - View child

<form (ngSubmit)="onSubmit()" #f = "ngForm">
in .ts, @Viewchild('f') signUpFormhere : ngForm

As discussed earlier, the local reference is good only when you want data on EVENT like submit or click
But the Viewchild method is better because we get to access the form even before any event trigger, any point of time we can access the form.

Usually we add required to the intpu tag meaning that required is a directive builtin angular. Likewise one can add email also.
<input type="email" name="some" required email/>

Angular dynamically adds the classes to the input tag whenever form gets valid or invalid Also there are other ways to know the validity like referencing the form on chnage or click or viewchild etc

Which Validators do ship with Angular? 

Check out the Validators class: https://angular.io/api/forms/Validators - these are all built-in validators, though that are the methods which actually get executed (and which you later can add when using the reactive approach).

For the template-driven approach, you need the directives. You can find out their names, by searching for "validator" in the official docs: https://angular.io/api?type=directive - everything marked with "D" is a directive and can be added to your template.

Additionally, you might also want to enable HTML5 validation (by default, Angular disables it). You can do so by adding the ngNativeValidate  to a control in your template.

When a form is defined in HTML, the angular converts it into a object and its upto me to keep which all fields in the object on submit or any event. So whichever field i want to keep in the object will be and mustbe having ngModel.
If i dont add ngmodel to a field then that field you cannot access in the .ts , in other words you cant see it in the NgForm object as in app.component.html (remove the ngModel for any field and console the form on submit)

71)
ngModel - No event or property binding ie withou any binding
[ngModel] - Property binding and no event binding and no 2way binding but only 1 way binding
([ngModel]) - 2 way

72)ngModelGroup - Groups the data fields into one and validation messages can be put based on ngModelGroup

73)You can access the form in the .ts file using the Viewchild reference like this.myform.setvalue()

74)Now it is time for reactive driven approach of forms. In templat driven approach the Angular infers the Form object from the DOM. In Reactive approach, the form is created automatically and is synchronized with DOM

75) We need to import ReactiveFormsModule instead of FormsModule in Reactive forms. The reactive approach will programatically build the form

76)In reactive approach we don't use the local refernce or viewchild reference because we already have access to it in the ts and we have created the controls hence

77)Any validations etc should be given in the ts file not in html in case of reactive

78)Incase of templat driven or reactive approach, inorder to group fields in form one should group them in HTML also under same div

79)Generally any angular property can be either -
<input formControlName = "string_name">
<input [formControlName] = "'binding_var'">

80)Generally in class object mechanism, we refer to the properties of class with `this` operator. But in some cases `this` wouldnt be accessible yet by angular. For instance
    this.reactiveForm = new FormGroup({
      ...
        'username': new FormControl(null, [Validators.required, this.forbiddenNames]),
    })
Here we are using custom validator this.forbiddenNames. Here in the Valdiation array of FormControl, we are passing only references to function and not calling them like below - 
        'username': new FormControl(null, [Validators.required(), this.forbiddenNames()]),
We are not calling as Angular calls it as and when required when change occurs. In case of custom validators the angular would not refer this validator to our clas. Hence we should bind with this -
this.forbiddenNames.bind(this)

81)There is something called valueChanges and statusChanges

82)Things to remember in template driven form -

    - ngModel must be tagged to the input in HTML so that it considers as formcontrol
    - name attribute is a must in the form whenever we add ngModel
    - we can assign the fields to localreference like #email #username and assign it to ngModel inorder for angular to consider it as control. Example: #email = "ngModel"
    - to the <form add the reference and assign it to the ngForm. Example: #customForm = "ngForm"

83) In templat approach, one does maximum in HTML and tries to get control of it in the ts file by just either using local reference or view child reference or by simply passing the local reference to the ngSubmit but in case of the reactive approach one does least in HTML may be vanilla HTML and controls it in the TS just by adding FormGroup and Formcontrolname in the HTML to connect to ts

84) remember in Forms, in create mode we use setValue() but on update mode we use patchValue(). If you want to know about FormArray then https://www.udemy.com/the-complete-guide-to-angular-2/learn/v4/t/lecture/12579508?start=0

85)Pipes - Is used to transform the output(from BE) in the template using |
There are custom and standard pipes
https://angular.io/api?query=pipe
Multiple pipes can be applied separated with | (Chaining Pipes)
The order of the pipes matter. Angular parses it from L to R.

86)Custom Pipes - C:\mySpace\treasure\treasure\treasure\KT\pipes-start\src\app\app.component.html

87)Pure Pipes - https://www.udemy.com/the-complete-guide-to-angular-2/learn/v4/t/lecture/6656586?start=0

88)The async pipe is used to transform the response object which comes after sometime from BE
Example - 
ngOnInit() {
        this.rowData = this.http.get('https://api.myjson.com/bins/15psn9');
    }
<ag-grid-angular 
    style="width: 500px; height: 500px;" 
    [rowData]="rowData | async"
    >
</ag-grid-angular>

Here the this.rowData is observable where we are not subscribing to it instead it is handled in the HTML using the pipe called async

89) The HTTP calls fetches result using AJAX -
Import http in the service and use it. This http is a observable and hence we need to subscribe else request to BE doesnot go.
this.http.post('https://udemy-cous',data) IN THE SERVICE
In ts file, call the above method from service and then subscribe to it

90)We can however add headers before placing the call which can be Content-type="json"
this.http.post(URL,data,options?)
this.http.post("www.some.com/", data, {headers: headers})
where headers = new Headers({'Content-type':'application/json})

91) we can use pipe(map()) inorder to convert the response object to another form which is also a observable
You can catch errors - https://www.udemy.com/the-complete-guide-to-angular-2/learn/v4/t/lecture/6656622?start=0

92) Generally when we send call to BE using http.get post put etc we get observable object to which we should subscribe in the ts file. This is general scenario, however we can still get data without subscribing to the observable using async pipe in the html file - https://www.udemy.com/the-complete-guide-to-angular-2/learn/v4/t/lecture/6656624?start=0
 The async pipe is subscribing to the observable.

 LEARN THE PIPES MAPS IN THE CURRENT PROJECT

 93).map() is not used in the Angualr 6 onwards instead we use pipe

 94)The http.get() etc will just give you a observable. However if you want the observable data to be modified slightly then modify using pipes, catcherror and maps. On the other hand the .ts file , we need to subscribe to the observable. So until to subscribe to the observable or modified observable in the service, the call wont be happening.

 95)The http get observable and subscribing can be however be split. Like having observable(may be modifying it using map pipe) in the service and calling that service function and then subscribing it in the ts file. Or on other hand use the observable and subscribe together.

 96)In traditional web apps like php html, we should keep on interacting with BE for any HTML rendering.
 Process > 
 The login form data is sent to BE > The BE will check if login info is present in DB > If yes, send the session id > The client and BE now uses this to communicate

 97)In SPA > Here reaching BE is not so much compared to the traditional type. Also in SPA the HTML is changed by Angular and not like traditional scenario.
The login form data is sent to BE > The BE will check if login info is present in DB > If yes, sends a JSON web token to the Client telling that user is logged in, which encodes some sensible information by hashing with algorithm > The client and BE now uses this to communicate

98) Login process

I am sending a POST request to a back end REST API, via a login component. I get an x-auth token back in the response headers. I should store this token so I can use it for all other API requests for the duration of the users logged in session
localStorage.setItem('token', response.access_token);

The entire process is -

https://stackoverflow.com/questions/48960671/web-tokens-in-angular-2/48962144

99) Login giving the username, password > the login happens successfully by sending back response with auth token and userinformation. We need to save it somewhere, and send that every time we send request to BE.
For any BE call > http.get("https://something.com?auth" + getToken())
Here we need to pass the query params auth like this.

100)Module ngModule - Tells whats required by the app, what services are used, what directives are used, what we need to include and what to exclude etc

101)in the ngModule 
> the declarations [] consists of components used, pipes and directives
> the imports [] consists of which other modules this module uses
> the providers [] consists of the services used in the app
> the bootstrap [] consists of the root component

102)Modularisation can be performed where a group of components,directives can be grouped together in a module based on feature, by doing this, if issue comes, we can debug module based

103)For any feature module, we should add CommonModule which gives access to ngif ngfor common directives. But in main app.module.ts we are not using the CommonModule but we have BrowserModule where BrowserModule will have all the features of CommonModule and also many more features which are required to bootstrap the application and show in the browser

104)We should not declare a module in more than one place.

105)in the app.module.ts we are defining the feature modules. The routes are placed in appRoutingModule which is placed in app.module.ts. On separating or Modularising the feature module, it is hard for Angular to determine and gets confused, hence good practise to keep the feature module specific routes separately

106)RouterModule.forRoot() only in the main route definition and RouterModule.forChild() will be only for every other child

107)Directives or Services cannot be used in multiple feature modules, You can either place it in the parent most module or create a shared module and put the directive in it.This is how we can share directives among. C:\mySpace\treasure\treasure\treasure\KT\ng-mean-todo-project\src\app\shared.module.ts

Don't put SERVICES in shared module.

108) If you have something like <router-outlet> in your app then the Modularisation will work but in case if you have <selector> like <app-shopping-list> then the root module ie AppModule will not understand the <app-shopping-list> element and will throw error. In case where selectors are used then you should declare the components in the declarations in the root module AppModule

109) Lazy Loading to improve the app performance

110) the javascript webpack bundle which contains our whole app will get downloaded at the beginning when user visits the page which means lot of code is never used because the user may not visit all the pages of the app. Hence most of the code in the bundle becomes useless at that point. Hence making use of lazy load will load the respective feature module on visit the route

Whatever is listed in the app.module.ts imports will be bundled by webpack. Hence remove those which are not visited when initial page loads and the ones removed should be added lazily using loadChildren : 'path + # + class name'

You can cross check the lazyloading by seeing the Network calls where 0_chunk.js will be added on loading the modules using lazyloading

111) Login Types -

Option 1 : jsession

Once user login, then a jsession ID will be sent to the FE and browser takes care to send this session on each call to the backend. We need not do anything in the frontend

This is stateful where there is a connection available and active for multiple calls to the be.

Option 2 : jwt

Once user login, then a jwt object token will be sent to the FE, the FE need to store it and send this token on each call to the BE may be by using interceptors or something

This is stateless because the client state is not preserved which is why we need to keep always sending the token to the backend.

112) Imagine you have main app.module and feature module feature.module, in both you have providers:[LogService] then the angular will keep a instance of it in the root level and will use in feature module also. Logservice will act as singleton. Then you will lazy load a module and there you have INJECT the Logservice(NOT IN PROVIDERS). In this case it still considers the root injector ie app module injector and will take from there. 

https://www.udemy.com/the-complete-guide-to-angular-2/learn/v4/t/lecture/6656720?start=0

Assume now that root module and child module and also the lazy loaded module all three has providers:[Logservice] in them. In this case the root and child shares the service but the lazy loaded uses a separate instance of the Logservice. Hence keep in mind that the lazy loaded module uses separate instance of the service which is not commonly used across the application. Other way of making the service private for that particular component is by making providers[] inside @Component

Dont provide services in the shared modules, esp when you are planning to lazy load the module.

113) Compilation - 
The angular cli compiles the code from typescript to javascript
The angular compiles the HTML code of templates into javascript(creating html element in the js).This is done because accessing the javascript is easier than accessing the DOM for performance reasons.

114)preloading modules - https://vsavkin.com/angular-router-preloading-modules-ba3c75e424cb

115)HttpClient and Http is almost same module but HttpClient has many features like -
-   It automatically extracts the _body from the response.
-   It fetches us the data in JSON

116)One can manually change or add headers for every call if needed by using new HttpHeaders() and also set new HttpParams() for every or specific call

this.headers = new HttpHeaders({
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Access-Control-Allow-Headers': '*',
            'Access-Control-Allow-Origin': '*',
            'Cache-Control': 'no-cache',
            'Pragma': 'no-cache',
            'Expires': 'Sat, 01 Jan 2000 00:00:00 GMT'
        });
        this.params = new HttpParams();
        this.options ={ headers: this.headers, params: this.params };
-------------------------------------------------------------------------
if (id) {
    params = new HttpParams().set('deviceType', id);
}
if (params) {
    this.options.params = params;
}
-------------------------------------------------------------------------
serviceCall(){ ....
return this.http.get(obj.url).pipe(
tap(() => this.timerReset()),
catchError(this.handleError.bind(this.self))); }

117)Imagine you have to send token for every call or may be you have to set headers for every call to the BE.
Instead of manually sending the data to each call, we can do it using interceptors
https://www.udemy.com/the-complete-guide-to-angular-2/learn/v4/t/lecture/7789386?start=0

118) typescript is used because it is understandable easily for the user to code and also that it is strict unlike javascript. Example:

myStr : String;
myStr = 4 // gives error as it is expecting string

The above will get converted to javascript and if you see the code in javascript it will be

var myStr;
myStr = 4 // this is correct as javascript is not strict but typescript is, which is good in a way so that we wont get any logical errors

Static methods can be instantiated directly without having to create a object.

119)Interfaces - these are set of properties with their types, when implementing this interface, the object will be forced to have those properties defined in them

check for .ts and .js for each of the types in C:\mySpace\treasure\treasure\treasure\KT\typescript

To compile > tsc file_name > this converts the ts to js and have a check of the js

120).map files help in debugging the code.

121)Proxy is redirect. If you have to mention a proxy path or redirect path on hit of APIs then mention it in the proxy.json

122)When we want the return statement to give us some boolean value but the value returing is object or string something then -

return !!this.myArr

123)When we have to send the BE with jwt token for every http service calls then in that case we need to send token back to BE for each call. Its cumbersome to handle it that way. Hence we are using interceptors where we need not send manually everytime the token, the interceptor will intercept the request and modify the call and attach the token which we want to pass

124)Webpack is used for -
bundle
minify
transpile
hash 

125)In case of Multi Page Application the server sends back the HTML files to be rendered in the FE and which leads to page refresh everytime.

Single Page Application is the one which interacts with the user by dynamically writing to current page rather than loading html pages from the server

126) Web pack is used for building the application, managing the application. We want to use web pack because
Assume i have 2 .css files and 2 .js files present.

In this scenario imagine The order of the above 2.js is important, first first.js should load and after which the second.js should. Incase the order is interchaged the application breaks.
Another scenario where i have plenty of css classes in multiple files, and also multiple js files, i can put them all in single file but it confuses us. Hence we modulirise it generally. When we modulirise the problem is with the order of importing the scripts. Rescue is the webpack

Webpack accepts 2 parts > In package.json, give a command as 
"build": "webpack whereToStart whereToStoreTheBundledAppDatas"
"build": "webpack src/js/app.js dist/bundle.js"

The web pack sees this app.js and import all the dependencies it has and further imports and so on and bundles them in the bundle.js file. 
Now in the index.html > remove all the script files included 
Add the bundle.js file alone in place of the scripts

The above actions can happen in the production also with more security like this -
"build:prod": "webpack whereToStart whereToStoreTheBundledAppDatas -p"
"build:prod": "webpack src/js/app.js dist/bundle.js -p"

Where -p is the command for minification. Go back and run this command in terminal and check for the bundle.js file where minification of the bundle has happened

127)When we hit the 'ng serve' command, the angular-cli internally uses webpack as module builder
Angular-CLI uses webpack internally
https://hackernoon.com/webpack-for-angular-developers-c8584a60e627

They did this by embedding webpack in the Angular CLI. Now, as an Angular developer you don’t need to know anything about webpack. The Angular CLI hides all that webpack complexity. However, that simplicity comes at the price of flexibility. By using the Angular CLI you lose the ability to configure and customize webpack.

The Angular CLI supports running a live browser reload experience to users by running ng serve. This will compile the application upon file saves and reload the browser with the newly compiled application. This is done by hosting the application in memory and serving it via webpack-dev-server.

128)If you develop angular locally with ng serve, there will be websocket connection being setup automatically between browser and local dev server, so when your code change, browser can automatically refresh.

Serve the application-
Angular includes a server, so that you can easily build and serve your app locally.

Launch the server by using the CLI command ng serve, with the --open option.

ng serve --open

The ng serve command launches the server, watches your files, and rebuilds the app as you make changes to those files.

--------------------------------
ng serve is for local reference only, it creates locally the bundles
ng - angular cli
ng build --aot will have ahead of time compilation with tree shaking feature which picks only which function is used ignoring rest (pick a node module npm where you dont use all functions)

in the builded code, check index.html which has the main.js file

When we are doing ng serve - locally then the build folder in the cache is created but not physically like the ng build --aot

The ng serve or ng build takes params from angular.json (webpack.json config file) and creates a index.html file which will be in the bundles. This file will be pointing to the <script main.js> then main.js loads

development server web serveer app server

polyfills does specific jobs for specific tools like chrome version, etc. The thing which works everywhere but not in the IE can be handled by writing polyfills for that particular IE version.

map files will be created in the bundles along with the other encrypted minified files in the production level. One can use it for debugging as everything will be NOT minified or NOT encrypted.

s3 bucket is like nginx, in our proj we use s3 bucket

129)Imagine you have a component somewhere and other components would like to instantiate the component by the tag <crspng-mega-table> but the problem is that the other components are not parents child with this mega component. Hence what one can do is whichever such components used by multiple other components will be all placed together in the @NgModule(widgets module) and would be loaded in the initial app.module.ts file. By doing this the angular loads those commonly used components initially only.